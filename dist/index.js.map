{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["// TODO: convert to TS\n// TODO: add tests for helper functions\n// TODO: create function for generating output\n// TODO: redo README\n// TODO: make sure that `function` anonymous function can work too!\n// TODO: make sure that functions can still log out expression -> dbg(() => someFunction());\n\ntype Expression = Function | any;\ntype NullableString = string | null;\n\ninterface LogParts {\n  location: NullableString;\n  expression?: string;\n  value: any;\n}\n\nfunction dbg(expression: Expression): any {\n  let value: any;\n  let reducedExpression: string;\n\n  const callerLocation = getCallerLocation(getStackTrace());\n\n  if (typeof expression === 'function') {\n    value = expression();\n    formatAndLog({\n      location: callerLocation,\n      expression: getReducedExpression(expression.toString()),\n      value,\n    });\n    return value;\n  }\n\n  value = expression;\n  formatAndLog({\n    location: callerLocation,\n    value,\n  });\n\n  return value;\n}\n\nfunction getReducedExpression(stringifiedExpression: string): string {\n  console.log('stringifiedExpression', stringifiedExpression);\n  // TODO: trim off anonymous function stuff (also taking care of random spaces and old way of doing it)\n  // return stringifiedExpression.trimStart('() => ');\n  return stringifiedExpression;\n}\n\nfunction getStackTrace(): string[] {\n  let trace: string = '';\n\n  try {\n    throw new Error('');\n  } catch (error) {\n    trace = error.stack || '';\n  }\n\n  const stack = trace.split('\\n').map(line => line.trim());\n  return stack.splice(stack[0] == 'Error' ? 2 : 1);\n}\n\nfunction getCallerLocation(stackTrace: string[]): NullableString {\n  // TODO: can't do this because the user could change the name when importing...\n  const traceIndex = 1 + stackTrace.findIndex(line => line.includes('dbg'));\n  // console.log('traceIndex', traceIndex);\n\n  if (!traceIndex) return null;\n\n  const stackLine = stackTrace[traceIndex];\n  // console.log('stackLine', stackLine);\n\n  const matches = stackTrace[traceIndex].match(/(\\/[\\w-]+)?(\\/[\\w-]+[.]js:[\\d]+):[\\d]+/);\n\n  if (matches === null) return '';\n\n  const directory = matches[1] || '';\n  const fileAndLine = matches[2] || '';\n  return `${directory}${fileAndLine}`;\n}\n\n// location and expression are optional\n// [location] expression = value\n// [src/main.rs:2] a * 2 = 4\nfunction formatAndLog({ location, expression, value }: LogParts): void {\n  const parts: string[] = [];\n  if (location !== null) parts.push(location);\n  if (expression !== undefined) parts.push(expression);\n  parts.push('=');\n  parts.push(`${value}`);\n\n  const log = parts.join(' ');\n\n  console.log(log);\n}\n\n// examples\ndbg(() => 4 + 3);\n\nconst something = 5 * dbg(() => 7 - 1);\ndbg(() => something);\n\ndbg(4 + 4);\n\nexport default dbg;\n"],"names":["dbg","expression","value","stringifiedExpression","callerLocation","stackTrace","traceIndex","findIndex","line","includes","matches","match","getCallerLocation","trace","Error","error","stack","split","map","trim","splice","getStackTrace","formatAndLog","location","toString","console","log","parts","push","undefined","join","const","something"],"mappings":"AAgBA,SAASA,EAAIC,OACPC,EAwBwBC,EArBtBC,EAyCR,SAA2BC,OAEnBC,EAAa,EAAID,EAAWE,mBAAUC,UAAQA,EAAKC,SAAS,aAG7DH,EAAY,OAAO,SAKlBI,EAAUL,EAAWC,GAAYK,MAAM,iDAE7B,OAAZD,EAAyB,OAEXA,EAAQ,IAAM,KACZA,EAAQ,IAAM,IAxDXE,CA4BzB,eACMC,EAAgB,aAGZ,IAAIC,MAAM,IAChB,MAAOC,GACPF,EAAQE,EAAMC,OAAS,OAGnBA,EAAQH,EAAMI,MAAM,MAAMC,aAAIV,UAAQA,EAAKW,gBAC1CH,EAAMI,OAAmB,SAAZJ,EAAM,GAAgB,EAAI,GAtCLK,UAEf,mBAAfpB,GACTC,EAAQD,IACRqB,EAAa,CACXC,SAAUnB,EACVH,YAewBE,EAfSF,EAAWuB,WAgBhDC,QAAQC,IAAI,wBAAyBvB,GAG9BA,SAlBHD,IAEKA,IAIToB,EAAa,CACXC,SAAUnB,QAFZF,EAAQD,IAMDC,GA6CT,SAASoB,+CACDK,EAAkB,GACP,OAAbJ,GAAmBI,EAAMC,KAAKL,QACfM,IAAf5B,GAA0B0B,EAAMC,KAAK3B,GACzC0B,EAAMC,KAAK,KACXD,EAAMC,QAAQ1B,OAERwB,EAAMC,EAAMG,KAAK,KAEvBL,QAAQC,IAAIA,GAId1B,oBAAU,IAEV+B,IAAMC,EAAY,EAAIhC,oBAAU,IAChCA,oBAAUgC,IAEVhC,EAAI"}