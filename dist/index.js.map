{"version":3,"sources":["parser.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["export default function parse(expression: string): string {\n  let value = expression;\n  value = trimLeft(value, ['function', '(', ')', '=>', '{', 'return']);\n  value = trimRight(value, ['}', ';']);\n  return value;\n}\n\nfunction trimLeft(str: string, list: string[]) {\n  return list.reduce((str, item) => {\n    return str.replace(new RegExp('^[' + item + '\\\\s]+'), '').trimLeft();\n  }, str.trim());\n}\n\nfunction trimRight(str: string, list: string[]) {\n  return list.reduce((str, item) => {\n    return str.replace(new RegExp('[' + item + '\\\\s]+$'), '').trimRight();\n  }, str.trim());\n}\n\n// TODO: use these as tests!\n\n// const x = 10;\n// const y = 2;\n// const height = 28;\n// const width = 5;\n// const depth = 100;\n// const something = 42;\n\n// const functions = [\n//   function () { return x + y; },\n//   function   ()   {\n//        return height * width * depth;\n//   },\n//   function() {\n//   return 4 + 3;\n//   },\n//   () => 4 + 1,\n//   () => variable * 2 + 1,\n//   () => {\n//     something + 1;\n//   }\n// ];\n\n// const parsedFunctions = functions.map(parse);\n\n// console.log(parsedFunctions);\n","// TODO: add tests for helper functions\n// TODO: create function for generating output\n// TODO: make sure that functions can still log out expression -> dbg(() => someFunction());\n\nimport { Expression, NullableString, LogParts } from './types';\nimport parse from './parser';\n\nfunction dbg(expression: Expression): any {\n  const logParts = evaluateDbg(expression);\n  formatAndLog(logParts);\n  return logParts.value;\n}\n\nfunction evaluateDbg(expression: Expression): LogParts {\n  if (typeof expression === 'function') {\n    return {\n      location: getCallerLocation(getStackTrace()),\n      expression: parse(expression.toString()),\n      value: expression(),\n    };\n  }\n\n  return {\n    location: getCallerLocation(getStackTrace()),\n    value: expression,\n  };\n}\n\nfunction getStackTrace(): string[] {\n  let trace: string = '';\n\n  try {\n    throw new Error('');\n  } catch (error) {\n    trace = error.stack || '';\n  }\n\n  const stack = trace.split('\\n').map(line => line.trim());\n  return stack.splice(stack[0] == 'Error' ? 2 : 1);\n}\n\nfunction getCallerLocation(stackTrace: string[]): NullableString {\n  const LOCATION = 1;\n\n  if (stackTrace.length < LOCATION + 1) return null;\n\n  const matches = stackTrace[LOCATION].match(/(\\/[\\w-]+)?(\\/[\\w-]+[.]js:[\\d]+):[\\d]+/);\n\n  if (matches === null) return null;\n\n  const directory = matches[1] || '';\n  const fileAndLine = matches[2] || '';\n\n  return `${directory}${fileAndLine}`;\n}\n\n// location and expression are optional\n// [location] expression = value\n// [src/main.rs:2] a * 2 = 4\nfunction formatAndLog({ location, expression, value }: LogParts): void {\n  const parts: string[] = [];\n  if (!!location) parts.push(`[${location}]`);\n  if (!!expression) {\n    parts.push(expression);\n    parts.push('=');\n  }\n  parts.push(`${value}`);\n\n  const log = parts.join(' ');\n\n  console.log(log);\n}\n\n// // examples\n// dbg(() => 4 + 3);\n\n// const something = 5 * dbg(() => 7 - 1);\n// dbg(() => something);\n\n// dbg(4 + 4);\n\nexport default dbg;\n"]}