{"version":3,"file":"index.mjs","sources":["../src/parser.ts","../src/tracer.ts","../src/index.ts"],"sourcesContent":["export default function parse(expression: string): string {\n  let trimmed = trimSides(expression);\n  let replaced = replaceCommonAnnoyances(trimmed);\n  return replaced;\n}\n\nfunction trimSides(value: string): string {\n  const LEFT_SIDE_VALUES = ['function', '(', ')', '=>', '{', 'return'];\n  const RIGHT_SIDE_VALUES = ['}', ';'];\n\n  value = trimLeft(value, LEFT_SIDE_VALUES);\n  value = trimRight(value, RIGHT_SIDE_VALUES);\n  return value;\n}\n\nfunction replaceCommonAnnoyances(value: string): string {\n  value = value.replace('_this', 'this'); // Nuxt\n  return value;\n}\n\nfunction trimLeft(str: string, list: string[]) {\n  return list.reduce((str, item) => {\n    return str.replace(new RegExp('^[' + item + '\\\\s]+'), '').trimLeft();\n  }, str.trim());\n}\n\nfunction trimRight(str: string, list: string[]) {\n  return list.reduce((str, item) => {\n    return str.replace(new RegExp('[' + item + '\\\\s]+$'), '').trimRight();\n  }, str.trim());\n}\n\n// TODO: use these as tests!\n\n// const x = 10;\n// const y = 2;\n// const height = 28;\n// const width = 5;\n// const depth = 100;\n// const something = 42;\n\n// const functions = [\n//   function () { return x + y; },\n//   function   ()   {\n//        return height * width * depth;\n//   },\n//   function() {\n//   return 4 + 3;\n//   },\n//   () => 4 + 1,\n//   () => variable * 2 + 1,\n//   () => {\n//     something + 1;\n//   }\n// ];\n\n// const parsedFunctions = functions.map(parse);\n\n// console.log(parsedFunctions);\n","import { NullableString } from './types';\n\nexport function getStackTrace(): string[] {\n  let trace: string = '';\n\n  try {\n    throw new Error('');\n  } catch (error) {\n    trace = error.stack || '';\n  }\n\n  const stack = trace.split('\\n').map(line => line.trim());\n  return stack.splice(stack[0] == 'Error' ? 2 : 1);\n}\n\nexport function getCallerLocation(stackTrace: string[]): NullableString {\n  // console.log(stackTrace);\n\n  const LOCATION = 2;\n\n  if (stackTrace.length < LOCATION + 1) return null;\n\n  let matches = stackTrace[LOCATION].match(fileInfoRegex());\n  // console.log('matches', matches);\n  if (matches === null) return null;\n\n  const directory = matches[1] || '';\n  let fileAndLine = matches[2] || '';\n  // strip out file query string\n  if (fileAndLine !== '' && matches.length >= 5) fileAndLine = fileAndLine.replace(matches[4], '');\n\n  return `${directory}${fileAndLine}`;\n}\n\n// examples of what needs to be matched\n// (at ./node_modules/vue-loader/lib/index.js?!./pages/index.vue?vue&type=script&lang=js&:40:8)\n// ./node_modules/vue-loader/lib/index.js?!./pages/index.vue?vue&type=script&lang=js&:40:8\nfunction fileInfoRegex() {\n  return /(\\/[\\w-]+)?(\\/[\\w-]+.(js|ts|jsx|tsx|vue|svelte)([\\w-?=&]*):[\\d]+):[\\d]+/;\n}\n\n// TODO: remove when regex is complete\n// original -> /(\\/[\\w-]+)?(\\/[\\w-]+[.]js:[\\d]+):[\\d]+/\n// (\\/[\\w-]+)?(\\/[\\w-]+.(js|ts|vue|svelte){1}[?]?[\\w&=]*[\\d]+):[\\d]+\n// (\\/[\\w-]+)?(\\/[\\w-]+.(js|vue):[\\d]+):[\\d]+\n// (\\/[\\w-]+)?(\\/[\\w-]+.(js|vue)([\\w-?=&]*):[\\d]+):[\\d]+\n","// TODO: add tests for helper functions\n// TODO: make sure that functions can still log out expression -> dbg(() => someFunction());\n\nimport { Expression, LogParts } from './types';\nimport parse from './parser';\nimport { getCallerLocation, getStackTrace } from './tracer';\n\nfunction dbg(expression: Expression): any {\n  const logParts = evaluateDbg(expression);\n  formatAndLog(logParts);\n  return logParts.value;\n}\n\nfunction evaluateDbg(expression: Expression): LogParts {\n  if (typeof expression === 'function') {\n    return {\n      location: getCallerLocation(getStackTrace()),\n      expression: parse(expression.toString()),\n      value: expression(),\n    };\n  }\n\n  return {\n    location: getCallerLocation(getStackTrace()),\n    value: expression,\n  };\n}\n\n// location and expression are optional\n// [location] expression = value\n// [src/main.rs:2] a * 2 = 4\nfunction formatAndLog({ location, expression, value }: LogParts): void {\n  const parts: string[] = [];\n  if (!!location) parts.push(`[${location}]`);\n  if (!!expression) {\n    parts.push(expression);\n    parts.push('=');\n  }\n  parts.push(`${value}`);\n\n  const log = parts.join(' ');\n\n  console.log(log);\n}\n\n// // examples\n// dbg(() => 4 + 3);\n\n// const something = 5 * dbg(() => 7 - 1);\n// dbg(() => something);\n\n// dbg(4 + 4);\n\nexport default dbg;\n"],"names":["parse","expression","str","list","reduce","item","replace","RegExp","trimRight","trim","trimLeft","getStackTrace","trace","Error","error","stack","split","map","line","splice","getCallerLocation","stackTrace","length","LOCATION","matches","match","directory","fileAndLine","logParts","location","toString","value","evaluateDbg","parts","push","log","join","console","formatAndLog"],"mappings":"SAAwBA,EAAMC,UA0B9B,SAAmBC,EAAaC,SAlBJ,CAAC,IAAK,KAmBpBC,gBAAQF,EAAKG,UAChBH,EAAII,QAAQ,IAAIC,OAAO,IAAMF,EAAO,UAAW,IAAIG,aACzDN,EAAIO,QAlBCD,CAJiB,CAAC,WAAY,IAAK,IAAK,KAAM,IAAK,UAc/CJ,gBAAQF,EAAKG,UAChBH,EAAII,QAAQ,IAAIC,OAAO,KAAOF,EAAO,SAAU,IAAIK,YArBpCT,EAsBjBQ,SAPOH,QAAQ,QAAS,iBCdjBK,QACVC,EAAgB,aAGZ,IAAIC,MAAM,IAChB,MAAOC,GACPF,EAAQE,EAAMC,OAAS,OAGnBA,EAAQH,EAAMI,MAAM,MAAMC,aAAIC,UAAQA,EAAKT,gBAC1CM,EAAMI,OAAmB,SAAZJ,EAAM,GAAgB,EAAI,YAGhCK,EAAkBC,MAK5BA,EAAWC,OAASC,EAAc,OAAO,SAEzCC,EAAUH,EAJG,GAIkBI,MAgB5B,8EAdS,OAAZD,EAAkB,OAAO,SAEvBE,EAAYF,EAAQ,IAAM,GAC5BG,EAAcH,EAAQ,IAAM,SAEZ,KAAhBG,GAAsBH,EAAQF,QAAU,IAAGK,EAAcA,EAAYrB,QAAQkB,EAAQ,GAAI,QAEnFE,EAAYC,iBCxBxB,SAAa1B,OACL2B,EAKR,SAAqB3B,SACO,mBAAfA,EACF,CACL4B,SAAUT,EAAkBT,KAC5BV,WAAYD,EAAMC,EAAW6B,YAC7BC,MAAO9B,KAIJ,CACL4B,SAAUT,EAAkBT,KAC5BoB,MAAO9B,GAhBQ+B,CAAY/B,UAuB/B,kBAtBe2B,aAAAA,eAAAA,QAuBPK,EAAkB,GAClBJ,GAAUI,EAAMC,SAASL,OACzB5B,IACJgC,EAAMC,KAAKjC,GACXgC,EAAMC,KAAK,MAEbD,EAAMC,QAAQH,OAERI,EAAMF,EAAMG,KAAK,KAEvBC,QAAQF,IAAIA,GAjCZG,GACOV,EAASG"}