{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["// TODO: convert to TS\n// TODO: add tests for helper functions\n// TODO: create function for generating output\n// TODO: redo README\n// TODO: make sure that `function` anonymous function can work too!\n// TODO: make sure that functions can still log out expression -> dbg(() => someFunction());\n\ntype Expression = Function | any;\ntype NullableString = string | null;\n\ninterface LogParts {\n  location: NullableString;\n  expression?: string;\n  value: any;\n}\n\nfunction dbg(expression: Expression): any {\n  const logParts = evaluateDbg(expression);\n  formatAndLog(logParts);\n  return logParts.value;\n}\n\nfunction evaluateDbg(expression: Expression): LogParts {\n  if (typeof expression === 'function') {\n    return {\n      location: getCallerLocation(getStackTrace()),\n      expression: getReducedExpression(expression.toString()),\n      value: expression(),\n    };\n  }\n\n  return {\n    location: getCallerLocation(getStackTrace()),\n    value: expression,\n  };\n}\n\nfunction getReducedExpression(stringifiedExpression: string): string {\n  console.log('stringifiedExpression', stringifiedExpression);\n  // TODO: trim off anonymous function stuff (also taking care of random spaces and old way of doing it)\n  // return stringifiedExpression.trimStart('() => ');\n  return stringifiedExpression;\n}\n\nfunction getStackTrace(): string[] {\n  let trace: string = '';\n\n  try {\n    throw new Error('');\n  } catch (error) {\n    trace = error.stack || '';\n  }\n\n  const stack = trace.split('\\n').map(line => line.trim());\n  return stack.splice(stack[0] == 'Error' ? 2 : 1);\n}\n\nfunction getCallerLocation(stackTrace: string[]): NullableString {\n  // TODO: can't do this because the user could change the name when importing...\n  // const traceIndex = 1 + stackTrace.findIndex(line => line.includes('dbg'));\n  // console.log('traceIndex', traceIndex);\n\n  // const stackLine = stackTrace[traceIndex];\n  // console.log('stackLine', stackLine);\n\n  if (stackTrace.length < 3) return null;\n\n  const matches = stackTrace[2].match(/(\\/[\\w-]+)?(\\/[\\w-]+[.]js:[\\d]+):[\\d]+/);\n\n  if (matches === null) return '';\n\n  const directory = matches[1] || '';\n  const fileAndLine = matches[2] || '';\n  return `${directory}${fileAndLine}`;\n}\n\n// location and expression are optional\n// [location] expression = value\n// [src/main.rs:2] a * 2 = 4\nfunction formatAndLog({ location, expression, value }: LogParts): void {\n  const parts: string[] = [];\n  if (location !== null) parts.push(location);\n  if (expression !== undefined) parts.push(expression);\n  parts.push('=');\n  parts.push(`${value}`);\n\n  const log = parts.join(' ');\n\n  console.log(log);\n}\n\n// examples\ndbg(() => 4 + 3);\n\nconst something = 5 * dbg(() => 7 - 1);\ndbg(() => something);\n\ndbg(4 + 4);\n\nexport default dbg;\n"],"names":["dbg","expression","logParts","location","getCallerLocation","getStackTrace","stringifiedExpression","toString","console","log","value","evaluateDbg","parts","push","undefined","join","formatAndLog","trace","Error","error","stack","split","map","line","trim","splice","stackTrace","length","matches","match","const","something"],"mappings":"sKAgBA,SAASA,EAAIC,OACLC,EAKR,SAAqBD,SACO,mBAAfA,EACF,CACLE,SAAUC,EAAkBC,KAC5BJ,YAWwBK,EAXSL,EAAWM,WAYhDC,QAAQC,IAAI,wBAAyBH,GAG9BA,GAdHI,MAAOT,KAIJ,CACLE,SAAUC,EAAkBC,KAC5BK,MAAOT,GAIX,IAA8BK,EApBXK,CAAYV,UA8D/B,kBA7DeC,aAAAA,eAAAA,QA8DPU,EAAkB,GACP,OAAbT,GAAmBS,EAAMC,KAAKV,QACfW,IAAfb,GAA0BW,EAAMC,KAAKZ,GACzCW,EAAMC,KAAK,KACXD,EAAMC,QAAQH,OAERD,EAAMG,EAAMG,KAAK,KAEvBP,QAAQC,IAAIA,GAtEZO,GACOd,EAASQ,MAyBlB,SAASL,QACHY,EAAgB,aAGZ,IAAIC,MAAM,IAChB,MAAOC,GACPF,EAAQE,EAAMC,OAAS,OAGnBA,EAAQH,EAAMI,MAAM,MAAMC,aAAIC,UAAQA,EAAKC,gBAC1CJ,EAAMK,OAAmB,SAAZL,EAAM,GAAgB,EAAI,GAGhD,SAAShB,EAAkBsB,MAQrBA,EAAWC,OAAS,EAAG,OAAO,SAE5BC,EAAUF,EAAW,GAAGG,MAAM,iDAEpB,OAAZD,EAAyB,OAEXA,EAAQ,IAAM,KACZA,EAAQ,IAAM,IAoBpC5B,oBAAU,IAEV8B,IAAMC,EAAY,EAAI/B,oBAAU,WAChCA,oBAAU+B,IAEV/B,EAAI"}